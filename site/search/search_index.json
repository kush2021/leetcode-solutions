{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetCode Solutions","text":"<p>This website will contain code and explanations for LeetCode problems I solve.</p>"},{"location":"#details","title":"Details","text":"<p>I will be using Python 3 to solve these problems. In addition, I will be using Google's Python Style Guide to style my work. Rather than trying to write particularly efficient or concise code, I will attempt to write clean code, including using separate functions to increase readability.</p> <p>The overall philosophy for solving these problems is that I will always strive to use the most efficient solution, considering both time and space complexity. For certain problems, the most efficient solution is rather unintuitive, but I will try my best to approach these problems from a ground-up level, explaining how to solve them without knowledge of certain niche algorithms.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The motivation for this project was to make learning data structures and algorithms as accessible as possible. I would like to provide clear, detailed, and concise explanations for problems that others may find challenging. I hope that others may benefit from these solutions.</p>"},{"location":"#credits","title":"Credits","text":"<p>The idea of documenting my solutions as an accessible website came from P.-Y.Chen. However, all of the work is my own, unless otherwise noted.</p>"},{"location":"#license","title":"License","text":"<p>Licensed under the MIT License.</p>"},{"location":"tags/","title":"Tags","text":"<p>The following is a list of relevant tags:</p>"},{"location":"tags/#array","title":"Array","text":"<ul> <li>1 - Two Sum</li> <li>Container With Most Water</li> <li>Three Sum</li> <li>Three Sum Closest</li> <li>Four Sum</li> <li>Remove Duplicates From Sorted Array</li> <li>Remove Element</li> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#backtracking","title":"Backtracking","text":"<ul> <li>Letter Combinations of a Phone Number</li> <li>Generate Parentheses</li> </ul>"},{"location":"tags/#binary-search","title":"Binary Search","text":"<ul> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#bit-manipulation","title":"Bit Manipulation","text":"<ul> <li>Divide Two Integers</li> </ul>"},{"location":"tags/#divide-and-conquer","title":"Divide and Conquer","text":"<ul> <li>Merge K Sorted Lists</li> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#dynamic-programming","title":"Dynamic Programming","text":"<ul> <li>Regular Expression Matching</li> <li>Generate Parentheses</li> <li>Longest Palindromic Substring</li> </ul>"},{"location":"tags/#easy","title":"Easy","text":"<ul> <li>1 - Two Sum</li> <li>Roman to Integer</li> <li>Longest Common Prefix</li> <li>Valid Parentheses</li> <li>Merge Two Sorted Lists</li> <li>Remove Duplicates From Sorted Array</li> <li>Remove Element</li> <li>Find the Index of the First Occurrence in a String</li> <li>Palindrome Number</li> </ul>"},{"location":"tags/#greedy","title":"Greedy","text":"<ul> <li>Container With Most Water</li> </ul>"},{"location":"tags/#hard","title":"Hard","text":"<ul> <li>Regular Expression Matching</li> <li>Merge K Sorted Lists</li> <li>Reverse Nodes in K-Group</li> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#hash-table","title":"Hash Table","text":"<ul> <li>1 - Two Sum</li> <li>Integer to Roman</li> <li>Roman to Integer</li> <li>Letter Combinations of a Phone Number</li> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#heap","title":"Heap","text":"<ul> <li>Merge K Sorted Lists</li> </ul>"},{"location":"tags/#linked-list","title":"Linked List","text":"<ul> <li>Remove Nth Node From End of List</li> <li>Add Two Numbers</li> <li>Merge Two Sorted Lists</li> <li>Merge K Sorted Lists</li> <li>Swap Nodes in Pairs</li> <li>Reverse Nodes in K-Group</li> </ul>"},{"location":"tags/#math","title":"Math","text":"<ul> <li>Integer to Roman</li> <li>Roman to Integer</li> <li>Add Two Numbers</li> <li>Divide Two Integers</li> <li>Reverse Integer</li> <li>Palindrome Number</li> </ul>"},{"location":"tags/#medium","title":"Medium","text":"<ul> <li>Container With Most Water</li> <li>Integer to Roman</li> <li>Four Sum</li> <li>Add Two Numbers</li> <li>Generate Parentheses</li> <li>Swap Nodes in Pairs</li> <li>Divide Two Integers</li> <li>Longest Substring Without Repeating Characters</li> <li>Longest Palindromic Substring</li> <li>Zigzag Conversion</li> <li>Reverse Integer</li> <li>String to Integer</li> </ul>"},{"location":"tags/#merge-sort","title":"Merge Sort","text":"<ul> <li>Merge K Sorted Lists</li> </ul>"},{"location":"tags/#recursion","title":"Recursion","text":"<ul> <li>Regular Expression Matching</li> <li>Merge Two Sorted Lists</li> <li>Swap Nodes in Pairs</li> <li>Reverse Nodes in K-Group</li> </ul>"},{"location":"tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#sorting","title":"Sorting","text":"<ul> <li>Three Sum</li> <li>Three Sum Closest</li> <li>Four Sum</li> </ul>"},{"location":"tags/#stack","title":"Stack","text":"<ul> <li>Valid Parentheses</li> </ul>"},{"location":"tags/#string","title":"String","text":"<ul> <li>Regular Expression Matching</li> <li>Integer to Roman</li> <li>Roman to Integer</li> <li>Longest Common Prefix</li> <li>Letter Combinations of a Phone Number</li> <li>Valid Parentheses</li> <li>Generate Parentheses</li> <li>Find the Index of the First Occurrence in a String</li> <li>Longest Substring Without Repeating Characters</li> <li>Longest Palindromic Substring</li> <li>Zigzag Conversion</li> <li>String to Integer</li> </ul>"},{"location":"tags/#string-matching","title":"String Matching","text":"<ul> <li>Find the Index of the First Occurrence in a String</li> </ul>"},{"location":"tags/#trie","title":"Trie","text":"<ul> <li>Longest Common Prefix</li> </ul>"},{"location":"tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>Container With Most Water</li> <li>Three Sum</li> <li>Three Sum Closest</li> <li>Four Sum</li> <li>Remove Nth Node From End of List</li> <li>Remove Duplicates From Sorted Array</li> <li>Remove Element</li> <li>Find the Index of the First Occurrence in a String</li> </ul>"},{"location":"solutions/1-two-sum/","title":"Two Sum","text":"","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#description","title":"Description","text":"<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution , and you may not use the same element twice.</p> <p>You can return the answer in any order.</p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#example-1","title":"Example 1","text":"<p>Input: <code>nums = [2,7,11,15], target = 9</code> Output: <code>[0,1]</code> Explanation: Because <code>nums[0] + nums[1] == 9</code> we return <code>[0, 1]</code>.</p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#example-2","title":"Example 2","text":"<p>Input: <code>nums = [3,2,4], target = 6</code> Output: <code>[1,2]</code></p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#example-3","title":"Example 3","text":"<p>Input: <code>nums = [3,3], target = 6</code> Output: <code>[0,1]</code></p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#constraints","title":"Constraints","text":"<ul> <li><code>2 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>-10^9 &lt;= target &lt;= 10^9</code></li> <li>Only one valid answer exists.</li> </ul>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#intuition","title":"Intuition","text":"<p>The first approach we may consider to solving this problem is a brute-force approach which utilizes a nested loop to consider all possible pairs of elements in <code>nums</code>. By considering every single pair of numbers, we can iterate until we find the pair that adds up to <code>target</code>, at which point we may return the indices of the numbers.</p> <p>Although no additional memory is required, we have to iterate through <code>nums</code> twice in the worst-case, giving us a time complexity of \\(O(n^2)\\). Is there a way we can solve this problem with only one iteration of <code>nums</code>?</p> <p>To answer this question, we must first realize that in order to solve the problem in a single pass, we need a way to store the previous numbers that we have found. Since we are guaranteed that each input has a single output, we do not need to worry about duplicate elements. Furthermore, given a single number, <code>num</code>, we know which other number we are looking for, <code>target - num</code>. These two facts will help us solve this problem efficiently.</p> <p>Let us first consider using a set to store our numbers. We can iterate through <code>nums</code> and during each iteration, check if <code>target - num</code> has been found (since <code>target - num</code> is the other number we need to find). If not, we can add <code>num</code> to our set. If so, we have found our answer. The problem is that we are asked to return the indices of the numbers, which we do not know.</p> <p>Instead of using a set, we can use a hash map that maps the numbers to their indices. We can follow the same algorithm as before, but now when we have successfully found a pair of numbers, we can return the indices using the map.</p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#approach","title":"Approach","text":"<ol> <li> <p>Initialize a hash map, <code>foundNums</code> to store the numbers and their indices as key-value pairs, respectively.</p> </li> <li> <p>Iterate through <code>nums</code>.</p> <p>a. Save <code>target - nums[i]</code> as <code>complement</code>.</p> <p>b. If <code>complement</code> is in <code>foundNums</code>, we can return <code>[foundNums[complement], i]</code>.</p> <p>c. Otherwise, we can update our hash map using <code>foundNums[num] = i</code>.</p> </li> </ol>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#complexity","title":"Complexity","text":"","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#time-complexity","title":"Time Complexity","text":"<p>The worst-case time complexity is \\(O(n)\\) because in the worst-case, we need to iterate through the entirety of <code>nums</code>. This happens when one of our numbers that add up to <code>target</code> is at the end of the array.</p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#space-complexity","title":"Space Complexity","text":"<p>The worst-case space complexity is \\(O(n)\\) because in the worst-case, we need to store \\(n\\) numbers and their indices in our hash map. This also happens when one of our numbers that add up to <code>target</code> is at the end of the array.</p>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/1-two-sum/#code","title":"Code","text":"<pre><code>class Solution:\n  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n    foundNums = dict()\n    for i, num in enumerate(nums):\n      complement = target - num\n      if complement in foundNums:\n        return [foundNums[complement], i]\n      foundNums[num] = i\n</code></pre>","tags":["Array","Easy","Hash Table"]},{"location":"solutions/10-regular-expression-matching/","title":"Regular Expression Matching","text":"","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/10-regular-expression-matching/#intuition","title":"Intuition","text":"<p>To solve this problem, we need a dynamic programming approach that consider fragments of the pattern and string at a time, building up to the complete pattern and string.</p> <p>Consider a table with characters of the pattern representing columns and characters of the string representing rows. We will also add an additional column and row and the start to represent the empty pattern and column. For the first cell (empty pattern and empty string), we can set this value to true (i.e., \"\" matches \"\"). For the first column, we can set all other values false (i.e., no character(s) will match with \"\"). The first row is a bit more tricky. We cannot set this row to false because we need to consider '*' characters. Of course, the empty string cannot match with any characters. However, consider the string \"\" and the pattern \"a*\". This is a valid match. The way we can check these cases is by looking at the first row and anywhere the '*' character appears, set the current cell to the value two columns back in the same row. For instance, the first row for the string \"\" and pattern \"a*b*c*\" will be TFTFTFT (consider the first empty pattern cell).</p> <p>To fill out the rest of the table, we will traverse row-by-row. If the string and pattern characters match or the pattern is a '.', we can set the current value to the previous diagonal value. The reason for this is because we are saying \"if the pattern and string up to the current character pair are a match and the current character pair is a match, then everything up to the current point is a match\".</p> <p>For the '*' case, we have two sub-cases. Let's consider the case where the '*' matches zero preceding characters. If so, we set the current cell to two previous cells (i.e., ignore the '*' and following character). If it does match the preceding character, we can set the current cell to the value directly above.</p>","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/10-regular-expression-matching/#approach","title":"Approach","text":"<p>Let \\(n\\) be the size of the string plus one. Let \\(m\\) be the size of the pattern plus one.</p> <p>Create an \\(n \\times m\\) matrix to represent the table with values initialized to false. The first cell will be true. Set the first row by looking for '*' characters and setting those cells to the value present two cells back.</p> <p>Traverse the rest of the table row-by-row. If there is a character match or the pattern character is a '.', set the current cell to the value immediately to the top-left. If there is a '*' match, first check if the preceding character matches. If not, set the current cell to the value two cells back. Otherwise, if there is a character match, keep the current cell as true (if already true) or set it to the cell immediately above. Return the last cell.</p>","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/10-regular-expression-matching/#complexity","title":"Complexity","text":"","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/10-regular-expression-matching/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(nm)\\) because we are looping twice.</p>","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/10-regular-expression-matching/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(nm)\\) because we need to maintain a table.</p>","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/10-regular-expression-matching/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  bool isMatch(std::string s, std::string p) {\n    const unsigned short n = s.size() + 1, m = p.size() + 1;\n    std::vector&lt;std::vector&lt;bool&gt;&gt; dp(n, std::vector&lt;bool&gt;(m));\n    dp[0][0] = true;\n    for (int i = 2; i &lt; m; i++) if (p[i - 1] == '*') dp[0][i] = dp[0][i - 2];\n    for (int i = 1; i &lt; n; i++) {\n      for (int j = 1; j &lt; m; j++) {\n        if ((p[j - 1] == '.') || (s[i - 1] == p[j - 1])) dp[i][j] = dp[i - 1][j - 1];\n        else if (p[j - 1] == '*') {\n          if (!dp[i][j - 1]) dp[i][j] = dp[i][j - 2];\n          if ((p[j - 2] == s[i - 1]) || (p[j - 2] == '.')) dp[i][j] = (dp[i][j] || dp[i - 1][j]);\n        }\n      }\n    }\n    return dp[n - 1][m - 1];\n  }\n};\n</code></pre>","tags":["Dynamic Programming","Hard","Recursion","String"]},{"location":"solutions/11-container-with-most-water/","title":"Container With Most Water","text":"","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/11-container-with-most-water/#intuition","title":"Intuition","text":"<p>To find the container with the most water, we have to consider the rectangles formed by the base and the height. The base is given by the difference of the indices of the walls we are considering and the height is given by the minimum of the height of the walls we are considering.</p> <p>The brute-force solution would be to find every possible rectangle and return the maximum container. However, this costs \\(O(n^2)\\) time.</p> <p>The optimal solution involves using two pointers, one at each end of the array, and searching inwards. The pointer that is moved inwards is the pointer corresponding to the limiting wall (i.e., the pointer corresponding to the minimum height).</p>","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/11-container-with-most-water/#approach","title":"Approach","text":"<p>Initialize two pointers, one starting at the beginning of the array and one at the end. Loop until the pointers meet each other (we do not have to consider the case where the pointers are equal because we know that this container will have a value of zero).</p> <p>At each iteration, we need to calculate the current area of water we can store. The base of the rectangle is given by the difference in the pointers and the height is given by the minimum wall. Next, we can modify the maximum water, if required. Finally, we need to increment the left pointer or decrement the right pointer. If the left pointer was the limiting wall, increment it. Otherwise, decrement the right pointer.</p>","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/11-container-with-most-water/#complexity","title":"Complexity","text":"","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/11-container-with-most-water/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) because we are traversing the array only once.</p>","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/11-container-with-most-water/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are only using constant variables for storage.</p>","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/11-container-with-most-water/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int maxArea(std::vector&lt;int&gt;&amp; height) {\n    unsigned int left = 0, right = height.size() - 1, maxWater = 0;\n    while (left &lt; right) {\n      maxWater = std::max(maxWater, (right - left) * std::min(height.at(left), height.at(right)));\n      if (height.at(left) &lt; height.at(right)) left++;\n      else right--;\n    }\n    return maxWater;\n  }\n};\n</code></pre>","tags":["Array","Greedy","Medium","Two Pointers"]},{"location":"solutions/12-integer-to-roman/","title":"Integer to Roman","text":"","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/12-integer-to-roman/#intuition","title":"Intuition","text":"<p>We can build up the numeric Roman value by converting the number in each decimal place (i.e., ones, tens, hundreds, thousands) to the corresponding number. All we need is a mapping from base-ten values to Roman numerals.</p>","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/12-integer-to-roman/#approach","title":"Approach","text":"<p>Create a nested array. The outer array will contain arrays representing each decimal place value. Each inner array will contain the conversion for the corresponding index. For instance, given the hundreds array, the fifth index will contain Roman numeral D.</p>","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/12-integer-to-roman/#complexity","title":"Complexity","text":"","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/12-integer-to-roman/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(1)\\) because the program does not run longer for lengthier inputs (subject to the LeetCode constraints).</p>","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/12-integer-to-roman/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) since it does not change with respect to the input.</p>","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/12-integer-to-roman/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  string intToRoman(int num) {\n    const std::vector&lt;std::vector&lt;std::string&gt;&gt; conversions = {\n      {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n      {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n      {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n      {\"\", \"M\", \"MM\", \"MMM\"}\n    };\n    return (\n      conversions.at(3).at((num / 1000) % 10)\n      + conversions.at(2).at((num / 100) % 10)\n      + conversions.at(1).at((num / 10) % 10)\n      + conversions.at(0).at(num % 10)\n    );\n  }\n};\n</code></pre>","tags":["Hash Table","Math","Medium","String"]},{"location":"solutions/13-roman-to-integer/","title":"Roman to Integer","text":"","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/13-roman-to-integer/#intuition","title":"Intuition","text":"<p>To go convert Roman numerals to integers, we just need to define when to subtract the decimal equivalent or add the decimal equivalent. For example, for the numeral VI, we want to add the numerals. For IV, we want to subtract the smaller one from the larger one.</p> <p>Consider looping backwards through the numeral. We can formalize the condition for adding vs. subtracting by noticing that whenever we are subtracting, the converted value (so far) will be at least larger than five times the current value (five because that is the next step up from numeral to numeral, e.g., I to V).</p>","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/13-roman-to-integer/#approach","title":"Approach","text":"<p>Use a hash map to define conversions between numerals and their decimal values. Loop through the string backwards. For each iteration, check if the current converted integer (the integer representing the entire converted set of characters) is larger than the single converted numeral (the character we are currently iterating on) times five. If so, we will subtract the numeral. Otherwise, we add.</p>","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/13-roman-to-integer/#complexity","title":"Complexity","text":"","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/13-roman-to-integer/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) because we are looping through the string.</p>","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/13-roman-to-integer/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is $O(1) because it does not depend on the input.</p>","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/13-roman-to-integer/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int romanToInt(string s) {\n    const std::unordered_map&lt;char, unsigned short&gt; conversions = {\n      {'I', 1},\n      {'V', 5},\n      {'X', 10},\n      {'L', 50},\n      {'C', 100},\n      {'D', 500},\n      {'M', 1000}\n    };\n    unsigned short integer = 0;\n    for (int i = s.size() - 1; i &gt;= 0; i--) {\n      const unsigned short converted = conversions.find(s[i]) -&gt; second;\n      integer = ((integer &gt;= (5 * converted)) ? (integer - converted) : (integer + converted));\n    }\n    return integer;\n  }\n};\n</code></pre>","tags":["Easy","Hash Table","Math","String"]},{"location":"solutions/14-longest-common-prefix/","title":"Longest Common Prefix","text":"","tags":["Easy","String","Trie"]},{"location":"solutions/14-longest-common-prefix/#intuition","title":"Intuition","text":"<p>For this problem, we can simply iterate through the array of strings in such a way where we check each starting character. If all characters match, we can append this character to our prefix string and move onto the next character. Otherwise, we can exit the function.</p>","tags":["Easy","String","Trie"]},{"location":"solutions/14-longest-common-prefix/#approach","title":"Approach","text":"<p>Create an empty string to hold our prefix. Loop through the size of the first string (i.e., number of characters in the first string). For each character, loop through the remaining strings in the array and check if the characters all match. If not (or if the character position is out-of-bounds), return our prefix. Otherwise, append the character to our prefix.</p>","tags":["Easy","String","Trie"]},{"location":"solutions/14-longest-common-prefix/#complexity","title":"Complexity","text":"","tags":["Easy","String","Trie"]},{"location":"solutions/14-longest-common-prefix/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(nm)\\) where \\(n\\) is the length of the shortest string and \\(m\\) is the length of the array.</p>","tags":["Easy","String","Trie"]},{"location":"solutions/14-longest-common-prefix/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Easy","String","Trie"]},{"location":"solutions/14-longest-common-prefix/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  std::string longestCommonPrefix(std::vector&lt;std::string&gt;&amp; strs) {\n    std::string commonPrefix = \"\";\n    for (int i = 0; i &lt; strs[0].size(); i++) {\n      const char possiblePrefixChar = strs[0][i];\n      for (int j = 1; j &lt; strs.size(); j++) {\n        if ((i &gt;= strs[j].size()) || (strs[j][i] != possiblePrefixChar)) return commonPrefix;\n      }\n      commonPrefix += possiblePrefixChar;\n    }\n    return commonPrefix;\n  }\n};\n</code></pre>","tags":["Easy","String","Trie"]},{"location":"solutions/15-three-sum/","title":"Three Sum","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/15-three-sum/#intuition","title":"Intuition","text":"<p>This problem can be solved by fixing a number and solving the two sum problem. The only additional subproblem we need to account for is avoiding duplicates. We can also do this by sorted the input array at the beginning and skipping traversal of duplicate elements.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/15-three-sum/#approach","title":"Approach","text":"<p>Sort the input array. Use a nested for loop. At each inner iteration, check if the three values (find the third using a binary search) add to zero. If so, add this to the final solution. Increment the loop pointer to skip copied elements. Do this for both loop pointers.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/15-three-sum/#complexity","title":"Complexity","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/15-three-sum/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n^2)\\) since we have two loops.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/15-three-sum/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/15-three-sum/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  std::vector&lt;std::vector&lt;int&gt;&gt; threeSum(std::vector&lt;int&gt;&amp; nums) {\n    std::vector&lt;std::vector&lt;int&gt;&gt; threeSumSet;\n    std::sort(nums.begin(), nums.end());\n    for (int i = 0; i &lt; nums.size() - 1; i++) {\n      for (int j = i + 1; j &lt; nums.size(); j++) {\n        if (std::binary_search(nums.begin() + j + 1, nums.end(), -nums[i] - nums[j])) {\n          threeSumSet.push_back(std::vector&lt;int&gt; {nums[i], nums[j], -nums[i] - nums[j]});\n        }\n        while (j &lt; nums.size() - 1 &amp;&amp; nums[j] == nums[j + 1]) j++;\n      }\n      while (i &lt; nums.size() - 1 &amp;&amp; nums[i] == nums[i + 1]) i++;\n    }\n    return threeSumSet;\n  }\n};\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/","title":"Three Sum Closest","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/#intuition","title":"Intuition","text":"<p>We will follow the same logic as Three Sum and change the design to return the closest sum instead of the sets of sums.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/#approach","title":"Approach","text":"<p>First, sort the array. We will use a loop to fix one number. The next two numbers can be searched using a two pointer approach. If at any point the sum equals the target, we can immediately return. Update the closest sum as we continue traversal.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/#complexity","title":"Complexity","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n^2)\\) because we have an outer loop and an inner two pointer search.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/16-three-sum-closest/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n    int closestSum = -999999;\n    std::sort(nums.begin(), nums.end());\n    for (unsigned short i = 0; i &lt; nums.size() - 1; i++) {\n      const int newTarget = target - nums.at(i);\n      unsigned short left = i + 1, right = nums.size() - 1;\n      while (left &lt; right) {\n        const int sum = nums.at(left) + nums.at(right);\n        if (sum &gt; newTarget) {\n          right--;\n        } else if (sum &lt; newTarget) {\n          left++;\n        } else {\n          return (sum + nums.at(i));\n        }\n        if (std::abs(sum - newTarget) &lt; std::abs(closestSum - target)) {\n          closestSum = sum + nums.at(i);\n        }\n      }\n    }\n    return closestSum;\n  }\n};\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/","title":"Letter Combinations of a Phone Number","text":"","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/#intuition","title":"Intuition","text":"<p>To solve this problem, we need to utilize the concept of backtracking. For each letter corresponding to each digit, we must recursively call the function to accumulate our string. Once our string is at its full value, we can append this to our result.</p>","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/#approach","title":"Approach","text":"<p>Create a hash map to define the digit-to-letter conversions. We will create a second function. This function will accumulate a string. This will correspond to one string in our final output list. Hence, we need to call this function for the number combinations we have.</p> <p>First, check if our string has finished accumulating. If so, we can append this value to our output list. If not, we can loop through the letters corresponding to the current digit and call backtracking by updating the accumulated string with each new character.</p>","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/#complexity","title":"Complexity","text":"","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n \\cdot 4^n)\\) because our backtracking tree has a depth of \\(n\\) and the total number of combinations is \\(O(4^n)\\).</p>","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/17-letter-combinations-of-a-phone-number/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  std::vector&lt;std::string&gt; letterCombinations(std::string digits) {\n    const std::unordered_map&lt;char, std::string&gt; lettersToPhoneNumbers = {\n      {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"},\n      {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"}\n    };\n    std::vector&lt;std::string&gt; combinedLetters;\n    if (digits.size() != 0) {\n      backtrack(0, \"\", combinedLetters, digits, lettersToPhoneNumbers);\n    }\n    return combinedLetters;\n  }\n\nprivate:\n  void backtrack(\n    unsigned short i,\n    std::string accumulatedLetters,\n    std::vector&lt;std::string&gt;&amp; combinedLetters,\n    const std::string digits,\n    const std::unordered_map&lt;char, std::string&gt; lettersToPhoneNumbers\n  ) {\n    if (accumulatedLetters.size() == digits.size()) {\n      combinedLetters.push_back(accumulatedLetters);\n    } else {\n      std::string phoneNumbers = lettersToPhoneNumbers.find(digits[i]) -&gt; second;\n      for (auto ch: phoneNumbers) {\n        backtrack(\n          i + 1,\n          accumulatedLetters + ch,\n          combinedLetters,\n          digits,\n          lettersToPhoneNumbers\n        );\n      }\n    }\n  }\n};\n</code></pre>","tags":["Backtracking","Hash Table","String"]},{"location":"solutions/18-four-sum/","title":"Four Sum","text":"","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/18-four-sum/#intuition","title":"Intuition","text":"<p>To solve this problem, we have to repeat the three sum problem while fixing an extra integer. This means we can have doubly-nested loops and then perform a two-pointer approach to find the quadruplets.</p>","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/18-four-sum/#approach","title":"Approach","text":"<p>Create a nested array to store the sums. If the input array has a size of less than four, we can return an empty list (since there are not enough numbers to form a quadruplet without repeating values). Sort the input array.</p> <p>Create a loop to traverse through <code>nums</code>. The loop will end once the index gets to <code>nums.size() - 3</code> because we need to leave at least three numbers worth of space for our next three values. Similarly, create another loop to traverse starting at one more than our previous loop index up to <code>nums.size() - 2</code>.</p> <p>Within the nested loop, we can find the complement value by subtracting our two current numbers we are iterating on from the target. This is the value the remaining three numbers must add to. Now, we can perform a two pointer approach to find any possible sums. Start with the left pointer being one greater than our inner loop index and the right pointer being the last number. If the sum is greater than our complement, we can decrement the right pointer, If the sum is less than our complement, we can increment our left pointer. If the sum equals our complement, we can increment the left pointer (or decrement the right pointer) and check if the last value in our sums array (the nested array of quadruplets) is equal to the new quadruplet that adds up to target. If not, we can add this quadruplet to our sums. This works because we are guaranteed that our sums is accumulating in sorted order so to check for duplicates, we only need to check the very last array.</p> <p>After the two-pointer approach is finished, we can increment our loop indices until the next value is different (make sure to not go out-of-range). Return the sums.</p>","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/18-four-sum/#complexity","title":"Complexity","text":"","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/18-four-sum/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n) * O(n) * O(n)\\) for the two loops and the two-pointer method. Sorting is \\(O(n\\log(n))\\). The total time complexity is then \\(O(n^3) + O(n\\log(n))\\) which is \\(O(n^3)\\).</p>","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/18-four-sum/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) since we are not using any additional space respective to the input size. We do not count the sums array because that is our return value.</p>","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/18-four-sum/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  std::vector&lt;std::vector&lt;int&gt;&gt; fourSum(std::vector&lt;int&gt;&amp; nums, int target) {\n    std::vector&lt;std::vector&lt;int&gt;&gt; sums;\n    const unsigned short n = nums.size();\n    if (n &lt; 3) {\n      return sums;\n    }\n    std::sort(nums.begin(), nums.end());\n    for (unsigned short i = 0; i &lt; (n - 3); i++) {\n      for (unsigned short j = i + 1; j &lt; (n - 2); j++) {\n        twoSum(sums, nums, target, i, j);\n        while ((j &lt; (n - 2)) &amp;&amp; (nums.at(j) == nums.at(j + 1))) {\n          j++;\n        }\n      }\n      while ((i &lt; (n - 1)) &amp;&amp; (nums.at(i) == nums.at(i + 1))) {\n        i++;\n      }\n    }\n    return sums;\n  }\n\nprivate:\n  void twoSum(\n    std::vector&lt;std::vector&lt;int&gt;&gt;&amp; sums,\n    const std::vector&lt;int&gt; nums,\n    const int target,\n    const unsigned short i,\n    const unsigned short j\n  ) {\n    long long complement = target - nums.at(i);\n    complement -= nums.at(j);\n    unsigned short left = j + 1, right = nums.size() - 1;\n    while (left &lt; right) {\n      const long long sum = nums.at(left) + nums.at(right);\n      if (sum &gt; complement) {\n        right--;\n      } else if (sum &lt; complement) {\n        left++;\n      } else {\n        const std::vector&lt;int&gt; potentialSum {nums.at(i), nums.at(j), nums.at(left), nums.at(right)};\n        if (sums.empty() || sums.at(sums.size() - 1) != potentialSum) {\n          sums.push_back(std::vector&lt;int&gt; {nums.at(i), nums.at(j), nums.at(left), nums.at(right)});\n        }\n        left++;\n      }\n    }\n  }\n};\n</code></pre>","tags":["Array","Medium","Sorting","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/","title":"Remove Nth Node From End of List","text":"","tags":["Linked List","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/#intuition","title":"Intuition","text":"<p>To solve this problem, the first approach we may consider is to do a first traversal of the linked list to find its length, and then a second traversal to remove the node.</p> <p>However, we can solve this problem in one pass. Consider using two pointers, <code>fast</code> and <code>slow</code>. Initialize fast to be the nth node in the linked list. Initialize slow to be at the head. Now, we can traverse both nodes until <code>fast</code> reaches the end. At this point, <code>slow</code> will be the node to remove (we will also keep track of a <code>previous</code> for removal).</p>","tags":["Linked List","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/#approach","title":"Approach","text":"<p>First, use a loop to initialize <code>fast</code> to the nth node.</p> <p>Next, set <code>slow</code> to be <code>head</code>. Traverse both nodes, along with a <code>previous</code> node to keep track of the node before <code>slow</code>, until the <code>fast</code> pointer is at the end.</p> <p>Finally, remove the <code>slow</code> node and return <code>head</code>.</p>","tags":["Linked List","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/#complexity","title":"Complexity","text":"","tags":["Linked List","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) where \\(n\\) is the size of the linked list.</p>","tags":["Linked List","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we only need to keep track of two pointers for any given input.</p>","tags":["Linked List","Two Pointers"]},{"location":"solutions/19-remove-nth-node-from-end-of-list/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  ListNode* removeNthFromEnd(ListNode* head, int n) {\n    return initSlowAndRemove(initFast(head, n), head);\n  }\n\nprivate:\n  ListNode* initFast(ListNode* head, const int n) {\n    ListNode* fast = head;\n    for (unsigned short i = 0; i &lt; (n - 1); i++) {\n      fast = fast -&gt; next;\n    }\n    return fast;\n  }\n\n  ListNode* initSlowAndRemove(ListNode* fast, ListNode* head) {\n    ListNode* slow = head;\n    ListNode* prev = nullptr;\n    while ((fast -&gt; next) != nullptr) {\n      prev = slow;\n      fast = fast -&gt; next;\n      slow = slow -&gt; next;\n    }\n    return removeNode(slow, prev, head);\n  }\n\n  ListNode* removeNode(ListNode* remove, ListNode* prev, ListNode* head) {\n    if (prev) {\n      prev -&gt; next = remove -&gt; next;\n      return head;\n    }\n    return head -&gt; next;\n  }\n};\n</code></pre>","tags":["Linked List","Two Pointers"]},{"location":"solutions/2-add-two-numbers/","title":"Add Two Numbers","text":"","tags":["Math","Medium","Linked List"]},{"location":"solutions/2-add-two-numbers/#intuition","title":"Intuition","text":"<p>The intuition for solving a problem like this comes from knowledge of elementary math algorithms. The addition algorithm for two integers was likely taught early on in school. To solve this problem, we need to replicate that algorithm in our program. It may seem problematic at first glance that the lists are in reverse order. However, elementary addition is done in reverse order. Indeed, the reverse order of the input parameters is to our benefit as addition is done from the smallest place-value digit to the largest.</p>","tags":["Math","Medium","Linked List"]},{"location":"solutions/2-add-two-numbers/#approach","title":"Approach","text":"<p>Initialize a new linked list for our solution. We will also need a value to represent any carry numbers (when adding single digits goes above 10). We will loop until all values have been traversed from <code>l1</code> and <code>l2</code>, and when the carry is zero. First, calculate the sum of the single digits. Note that <code>l1</code> or <code>l2</code> may be null. The carry also needs to be included in this computation. Next, reset the carry to zero. If the sum is greater than or equal to 10, we need to replace the sum with <code>sum % 10</code> and set the carry to one. This sum value will be the next digit for our solution. Finally, increment the pointers.</p>","tags":["Math","Medium","Linked List"]},{"location":"solutions/2-add-two-numbers/#complexity","title":"Complexity","text":"","tags":["Math","Medium","Linked List"]},{"location":"solutions/2-add-two-numbers/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(\\max\\{n, m\\})\\) where \\(n\\) and \\(m\\) are the lengths of <code>l1</code> and <code>l2</code>, respectively. This is because we must loop for every value in both <code>l1</code> and <code>l2</code>. We take the maximum instead of the sum because the sum would imply that we need to loop once per each element in both lists. However, the first \\(\\min\\{n, m\\}\\) elements are done in a single loop.</p>","tags":["Math","Medium","Linked List"]},{"location":"solutions/2-add-two-numbers/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are not requiring any variable-amount of memory. Since we are returning the solution list, it does not go against our memory complexity.</p>","tags":["Math","Medium","Linked List"]},{"location":"solutions/2-add-two-numbers/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode();\n        ListNode* current = head;\n        unsigned char carry = 0;\n        while (l1 != nullptr || l2 != nullptr || carry) {\n            unsigned char sum = ((l1 != nullptr) ? l1 -&gt; val : 0) + ((l2 != nullptr) ? l2 -&gt; val : 0) + carry;\n            carry = 0;\n            if (sum &gt;= 10) {\n                sum %= 10;\n                carry = 1;\n            }\n            current -&gt; next = new ListNode(sum);\n            current = current -&gt; next;\n            l1 = (l1 != nullptr) ? l1 -&gt; next : nullptr;\n            l2 = (l2 != nullptr) ? l2 -&gt; next : nullptr;\n        }\n        return head -&gt; next;\n    }\n};\n</code></pre>","tags":["Math","Medium","Linked List"]},{"location":"solutions/20-valid-parentheses/","title":"Valid Parentheses","text":"","tags":["Easy","Stack","String"]},{"location":"solutions/20-valid-parentheses/#intuition","title":"Intuition","text":"<p>We can utilize a stack to easily solve this problem. A stack is a last-in, first-out data structure that can remember the order in which parentheses were traversed, allowing us to remove matching parentheses when possible.</p>","tags":["Easy","Stack","String"]},{"location":"solutions/20-valid-parentheses/#approach","title":"Approach","text":"<p>Initialize an empty stack. For each character in the input string, if the character is an open type, we can push it onto our stack. If not, we can pop the last value from the stack and check if it is the corresponding opening parentheses for our current character. If not, we can immediately return false. If so, we can continue traversing.</p> <p>Before returning true, we need to make sure the stack is empty (i.e., all open parentheses that were pushed have found a match).</p>","tags":["Easy","Stack","String"]},{"location":"solutions/20-valid-parentheses/#complexity","title":"Complexity","text":"","tags":["Easy","Stack","String"]},{"location":"solutions/20-valid-parentheses/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) where \\(n\\) is the length of the input string. This is because we are executing the algorithm once per character.</p>","tags":["Easy","Stack","String"]},{"location":"solutions/20-valid-parentheses/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(n)\\) where \\(n\\) is the length of the input string. This is because we are using a stack which, in the worst case, will hold all \\(n\\) parentheses (i.e., when the input only contains open parentheses).</p>","tags":["Easy","Stack","String"]},{"location":"solutions/20-valid-parentheses/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  bool isValid(string s) {\n    std::stack&lt;char&gt; parentheses;\n    for (auto ch: s) {\n      if (isOpenParentheses(ch)) {\n        parentheses.push(ch);\n      } else if (\n        parentheses.empty()\n        || !isParenthesesMatch(parentheses.top(), ch)\n      ) {\n        return false;\n      } else {\n        parentheses.pop();\n      }\n    }\n    return parentheses.empty();\n  }\n\nprivate:\n  inline bool isOpenParentheses(const char ch) {\n    return (\n      ch == '('\n      || ch == '{'\n      || ch == '['\n    );\n  }\n\n  inline bool isParenthesesMatch(const char ch1, const char ch2) {\n    if (ch1 == '(') {\n      return (ch2 == ')');\n    }\n    if (ch1 == '{') {\n      return (ch2 == '}');\n    }\n    if (ch1 == '[') {\n      return (ch2 == ']');\n    }\n    throw;\n  }\n};\n</code></pre>","tags":["Easy","Stack","String"]},{"location":"solutions/21-merge-two-sorted-lists/","title":"Merge Two Sorted Lists","text":"","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/21-merge-two-sorted-lists/#intuition","title":"Intuition","text":"<p>The intuition for this problem is fairly straightforward. We will iteratively compare each list node value and append the smaller one to the list we are creating.</p>","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/21-merge-two-sorted-lists/#approach","title":"Approach","text":"<p>Ensure that both lists are non-empty. If one list is non-empty, return the other list.</p> <p>Set a <code>head</code> variable to the smaller of the two nodes. Set another <code>tail</code> to the head. Loop until one list becomes non-empty. Add the lower node to the end of <code>tail</code> and increment pointer for that list.</p> <p>Check if any list has nodes remaining. If so, add those nodes to <code>tail</code>. Return <code>head</code>.</p>","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/21-merge-two-sorted-lists/#complexity","title":"Complexity","text":"","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/21-merge-two-sorted-lists/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(\\min\\{n, m\\})\\) where \\(n\\) and \\(m\\) are the lengths of <code>list1</code> and <code>list2</code>, respectively. This is because we only need to loop until one list is empty.</p>","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/21-merge-two-sorted-lists/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are creating the new list in place.</p>","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/21-merge-two-sorted-lists/#code","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (list1 == nullptr) {\n      return list2;\n    } else if (list2 == nullptr) {\n      return list1;\n    }\n    ListNode* head = assignHead(list1, list2);\n    ListNode* tail = head;\n    while (bothListsHaveNodes(list1, list2)) {\n      if (isFirstValSmaller(list1, list2)) {\n        addNode(list1, tail);\n      } else {\n        addNode(list2, tail);\n      }\n    }\n    addRemainingNodes(tail, list1, list2);\n    return head;\n  }\n\nprivate:\n  ListNode* assignHead(ListNode*&amp; l1, ListNode*&amp; l2) {\n    ListNode* head;\n    if (isFirstValSmaller(l1, l2)) {\n      head = l1;\n      l1 = l1 -&gt; next;\n    } else {\n      head = l2;\n      l2 = l2 -&gt; next;\n    }\n    return head;\n  }\n\n  inline bool isFirstValSmaller(const ListNode* l1, const ListNode* l2) {\n    return ((l1 -&gt; val) &lt; (l2 -&gt; val));\n  }\n\n  inline bool bothListsHaveNodes(const ListNode* l1, const ListNode* l2) {\n    return !(l1 == nullptr || l2 == nullptr);\n  }\n\n  void addNode(ListNode*&amp; add, ListNode*&amp; tail) {\n    tail -&gt; next = add;\n    tail = tail -&gt; next;\n    add = add -&gt; next;\n  }\n\n  void addRemainingNodes(ListNode*&amp; tail, ListNode* l1, ListNode* l2) {\n    if (l1 != nullptr) {\n      tail -&gt; next = l1;\n    } else if (l2 != nullptr) {\n      tail -&gt; next = l2;\n    }\n  }\n};\n</code></pre>","tags":["Easy","Linked List","Recursion"]},{"location":"solutions/22-generate-parentheses/","title":"Generate Parentheses","text":"","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/22-generate-parentheses/#intuition","title":"Intuition","text":"<p>We can solve this problem using a helper function for recursive backtracking. During each function call, there are three possible cases. Either the current string is finished, we can add an open parentheses, or we can add a closed parentheses. To check if the string is finished, we can check if its length is <code>n * 2</code>. We can add <code>n</code> open parentheses. We can add a closing parentheses as long as there are more open parentheses.</p>","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/22-generate-parentheses/#approach","title":"Approach","text":"<p>Define a backtracking function that takes <code>n</code>, an array of strings, the current string, and the number of open parentheses. First, check if the string is finished. If not, we have if-statements. If the count of open parentheses is smaller than <code>n</code>, we can do a recursive call and add an open parentheses to our string. If there are less closed parentheses than open, we can do a recursive call and add a closed parentheses to our string. Return the array.</p>","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/22-generate-parentheses/#complexity","title":"Complexity","text":"","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/22-generate-parentheses/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(2^n)\\) where \\(n\\) is the initial <code>n</code> value. This is because we are doing two recursive calls for each function (i.e., the branching factor of the call tree is two), and the functions are called \\(n\\) times before terminating (i.e., the length of the call tree is \\(n\\)).</p>","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/22-generate-parentheses/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are not using additional space besides our return value.</p>","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/22-generate-parentheses/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  std::vector&lt;std::string&gt; generateParenthesis(int n) {\n    std::vector&lt;std::string&gt; parentheses;\n    backtrack(n, parentheses, \"\", 0);\n    return parentheses;\n  }\n\nprivate:\n  void backtrack(\n    const int n,\n    std::vector&lt;std::string&gt;&amp; parentheses,\n    std::string current,\n    unsigned short open\n  ) {\n    if (current.size() == (n * 2)) {\n      parentheses.push_back(current);\n    } else {\n      if (open &lt; n) {\n        backtrack(n, parentheses, current + '(', open + 1);\n      }\n      if ((current.size() / 2) &lt; open) {\n        backtrack(n, parentheses, current + ')', open);\n      }\n    }\n  }\n};\n</code></pre>","tags":["Backtracking","Dynamic Programming","Medium","String"]},{"location":"solutions/23-merge-k-sorted-lists/","title":"Merge K Sorted Lists","text":"","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/23-merge-k-sorted-lists/#intuition","title":"Intuition","text":"<p>We can solve this problem by taking advantage of a data structure that can easily store and return the minimum value of all lists: a minimum heap (or priority queue). We will insert all nodes into the heap and until the heap is empty, continue popping the smallest value, adding it to our list, and replacing the popped value with the next one from that list.</p>","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/23-merge-k-sorted-lists/#approach","title":"Approach","text":"<p>Create a minimum heap. Insert all nodes into the heap (as long as they are not null). If all the nodes are null, we can return null. Create a head and tail node for our new list.</p> <p>We can loop until the heap is empty. During each iteration, pop the smallest value from the heap and append it to our list. Afterwards, check if the next node in the list that the smallest node belongs to exists. If so, add it to the heap.</p> <p>Return our new list.</p>","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/23-merge-k-sorted-lists/#code","title":"Code","text":"","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/23-merge-k-sorted-lists/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n\\log{k})\\) where \\(n\\) is the total number of elements in all lists and \\(k\\) is the total number of lists. Our main loop will iterate \\(n\\) times and each iteration costs \\(\\log{k}\\) for our heap operations.</p>","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/23-merge-k-sorted-lists/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(k)\\) because we have a heap that contains \\(k\\) elements at a time.</p>","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/23-merge-k-sorted-lists/#code_1","title":"Code","text":"<pre><code>class Solution {\npublic:\n  ListNode* mergeKLists(std::vector&lt;ListNode*&gt;&amp; lists) {\n    std::priority_queue&lt;ListNode*, std::vector&lt;ListNode*&gt;, compare&gt; minHeap;\n    populateHeap(minHeap, lists);\n    if (minHeap.size() == 0) return nullptr;\n    ListNode* head = new ListNode();\n    ListNode* tail = head;\n    merge(tail, minHeap);\n    return (head -&gt; next);\n  }\n\nprivate:\n  struct compare {\n    bool operator() (const ListNode* a, const ListNode* b) {\n      return (a -&gt; val) &gt; (b -&gt; val);\n    }\n  };\n\n  void populateHeap(\n    std::priority_queue&lt;ListNode*, std::vector&lt;ListNode*&gt;, compare&gt;&amp; heap,\n    const std::vector&lt;ListNode*&gt; lists\n  ) {\n    for (auto list: lists) if (list) heap.push(list);\n  }\n\n  void merge(\n    ListNode*&amp; tail,\n    std::priority_queue&lt;ListNode*, std::vector&lt;ListNode*&gt;, compare&gt;&amp; heap\n  ) {\n    while (heap.size()) {\n      ListNode* smallest = heap.top();\n      heap.pop();\n      tail -&gt; next = smallest;\n      tail = tail -&gt; next;\n      smallest = smallest -&gt; next;\n      if (smallest) heap.push(smallest);\n    }\n  }\n};\n</code></pre>","tags":["Divide and Conquer","Hard","Heap","Linked List","Merge Sort"]},{"location":"solutions/24-swap-nodes-in-pairs/","title":"Swap Nodes in Pairs","text":"","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/24-swap-nodes-in-pairs/#intuition","title":"Intuition","text":"<p>To solve this problem, we can simply traverse the list in pairs, swapping the nodes at each iteration. We must also remember to change a previous node's next once the current pair swaps. Consider the linked list \\(1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4\\). We cans swap the first nodes resulting in \\(2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4\\). Next, we can swap the last two nodes, resulting in \\(2 \\rightarrow 1 \\rightarrow 4 \\rightarrow 3\\). At this iteration, we also need to change the previous node's (represented by the \\(1\\)) next to point to \\(4\\) instead of \\(3\\). This applies to all iterations besides the first.</p>","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/24-swap-nodes-in-pairs/#approach","title":"Approach","text":"<p>Define pointers for <code>left</code>, <code>right</code>, and <code>prev</code>. <code>left</code> and <code>right</code> will point to <code>head</code> and <code>prev</code> will point to null.</p> <p>If <code>head</code> is not null and there are at least two nodes, we can set the head to be <code>left -&gt; next</code> since after the swap, the first node will be the current second node.</p> <p>While <code>left</code> is not null, we can iterate through the list. Assign <code>right</code> to be <code>left -&gt; next</code>, provided that node exists. Swap the two nodes. If <code>prev</code> exists, set that node's next to be <code>right</code>. Assign <code>prev</code> to be <code>left</code> and increment <code>left</code>.</p> <p>Return <code>head</code>.</p>","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/24-swap-nodes-in-pairs/#complexity","title":"Complexity","text":"","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/24-swap-nodes-in-pairs/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) where \\(n\\) is the number of nodes in the input list. This is because we need to traverse the entire list once to swap all pairs of nodes.</p>","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/24-swap-nodes-in-pairs/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because our memory requirements are not dependent on the size of the input list.</p>","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/24-swap-nodes-in-pairs/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  ListNode* swapPairs(ListNode* head) {\n    ListNode* left = head;\n    ListNode* right = left;\n    ListNode* prev = nullptr;\n    if (head &amp;&amp; left -&gt; next) head = left -&gt; next;\n    while (left) {\n      if (!(left -&gt; next)) break;\n      right = left -&gt; next;\n      swap(left, right);\n      if (prev) prev -&gt; next = right;\n      prev = left;\n      left = left -&gt; next;\n    }\n    return head;\n  }\n\nprivate:\n  void swap(ListNode*&amp; a, ListNode*&amp; b) {\n    a -&gt; next = b -&gt; next;\n    b -&gt; next = a;\n  }\n};\n</code></pre>","tags":["Linked List","Medium","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/","title":"Reverse Nodes in K-Group","text":"","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/#intuition","title":"Intuition","text":"<p>This problem can be solved by reasoning about how to reverse \\(k\\) nodes at a time. Reversing all of the nodes is a fairly straightforward task. We can simply switch the direction of each pointer in the list and change the head.</p> <p>Extending this for our problem, we can perform this reversal \\(k\\) nodes at a time and we also need to keep track of the previous group's tail and the next group's head (so we can reference these to assign the correct pointers).</p>","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/#approach","title":"Approach","text":"<p>First, create a dummy head node that points to <code>head</code>. Set the previous group's tail to <code>dummy</code>.</p> <p>We will iterate the rest of the list until there are no more \\(k\\) node groups left. Get the \\(k\\)th node. If it is <code>null</code>, we can exit. Set the next group's head to <code>kth.next</code> and <code>prev</code> to <code>kth.next</code>. Set <code>current</code> to <code>groupTail.next</code>.</p> <p>While <code>current != groupHead</code>, we can reverse the \\(k\\) nodes. Use a temporary variable to hold <code>current.next</code>. Set the <code>current.next</code> to <code>prev</code> and <code>prev</code> to <code>current</code>. Finally, set <code>current</code> to <code>next</code>.</p> <p>Now, we can assign <code>groupTail.next</code> to <code>kth</code> and advance <code>groupTail</code>.</p> <p>Return <code>dummy.next</code>.</p>","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/#complexity","title":"Complexity","text":"","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) because we must iterate through the entire list to perform the algorithm.</p>","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are not using any space relative to the input size.</p>","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/25-reverse-nodes-in-k-group/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  ListNode* reverseKGroup(ListNode* head, int k) {\n    ListNode* dummy = new ListNode(0, head);\n    ListNode* groupTail = dummy;\n    while (true) {\n      ListNode* kth = getKth(groupTail, k);\n      if (!kth) break;\n      ListNode* groupHead = kth -&gt; next;\n      ListNode* prev = kth -&gt; next;\n      ListNode* current = groupTail -&gt; next;\n      while (current != groupHead) {\n        ListNode* next = current -&gt; next;\n        current -&gt; next = prev;\n        prev = current;\n        current = next;\n      }\n      ListNode* next = groupTail -&gt; next;\n      groupTail -&gt; next = kth;\n      groupTail = next;\n    }\n    return dummy -&gt; next;\n  }\n\nprivate:\n  ListNode* getKth(ListNode* current, const int k) {\n    for (unsigned short i = 0; i &lt; k; i++) {\n      if (!current) return nullptr;\n      current = current -&gt; next;\n    }\n    return current;\n  }\n};\n</code></pre>","tags":["Hard","Linked List","Recursion"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/","title":"Remove Duplicates From Sorted Array","text":"","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/#intuition","title":"Intuition","text":"<p>To address this issue effectively, we must tackle two key sub-problems with optimal solutions. Firstly, we need a method to identify duplicates, and secondly, we need a strategy to shuffle the elements in-place.</p> <p>Identifying duplicates can be accomplished by simply comparing the value at <code>nums[i]</code> with the value at <code>nums[i - 1]</code>. If they match, we've detected a duplicate at index <code>i</code>.</p> <p>For shuffling the elements in-place, a two-pointer approach proves beneficial. One pointer traverses through each value, checking for duplicates, while the second pointer indicates the next position in the array that requires filling. Visualize this process as systematically iterating through the array and overwriting it from the beginning, ensuring only unique integers are retained.</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/#approach","title":"Approach","text":"<p>Let's initialize the pointer to track our position at one and set the counter for unique values to one. This is possible as we're assured of at least one value in the array.</p> <p>Moving forward, we'll iterate through the array, commencing from the second value (<code>i = 1</code>). If a duplicate is encountered, we'll proceed with the iteration. Conversely, upon encountering a unique value, we'll assign this value to the array at the index indicated by our position pointer. Additionally, we'll increment our counter for unique integers.</p> <p>Finally, we'll return the count of unique integers identified.</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/#complexity","title":"Complexity","text":"","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/#time-complexity","title":"Time Complexity","text":"<p>We need to traverse the input array once to remove all the duplicates. This gives us a time complexity of \\(O(n)\\).</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/#space-complexity","title":"Space Complexity","text":"<p>Since our memory usage is not dependent on the input array, our space complexity is \\(O(1)\\).</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/26-remove-duplicates-from-sorted-array/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int removeDuplicates(std::vector&lt;int&gt;&amp; nums) {\n    unsigned short positionToFill = 1, uniqueCount = 1;\n    for (unsigned short i = 1; i &lt; nums.size(); i++) {\n      if (nums.at(i) != nums.at(i - 1)) {\n        nums.at(positionToFill++) = nums.at(i);\n        uniqueCount++;\n      }\n    }\n    return uniqueCount;\n  }\n};\n</code></pre>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/","title":"Remove Element","text":"","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/#intuition","title":"Intuition","text":"<p>The approach for this problem is very similar to the approach used in 25 - Remove Duplicates From Sorted Array. However, instead of removing duplicate elements, we will be removing elements that are equal to <code>val</code>.</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/#approach","title":"Approach","text":"<p>Initialize a pointer to keep track of the next position in the array that needs to be filled.</p> <p>Iterate through the array. Whenever an element not equal to <code>val</code> is encountered, assign that element to the index of our fill pointer and increment.</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/#complexity","title":"Complexity","text":"","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) because we need to iterate through the input array.</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are not using any extra space for larger input sizes.</p>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/27-remove-element/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    unsigned short fillIndex = 0;\n    for (unsigned short i = 0; i &lt; nums.size(); i++) {\n      if (nums.at(i) != val) {\n        nums.at(fillIndex++) = nums.at(i);\n      }\n    }\n    return fillIndex;\n  }\n};\n</code></pre>","tags":["Array","Easy","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/","title":"Find the Index of the First Occurrence in a String","text":"","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/#intuition","title":"Intuition","text":"<p>We can solve this problem trivially using a nested for-loop to compare the characters of the needle with the characters in the haystack. However, to solve this problem optimally, we need to apply the Knuth-Morris-Pratt (KMP) algorithm.</p> <p>The KMP algorithm is used for pattern matching in strings. It takes advantage of a prefix table to help avoid unnecessary comparisons. The prefix table is formed by setting the size of the table to the size of the pattern and the value at index <code>i</code> to the length of the longest proper prefix and suffix up to that character.</p> <p>Let us consider an example. Consider the string <code>ABABCAB</code>. The prefix table will be an array of length seven. For any given pattern, we can set the first value to zero. This is because for the substring of length one, there are no proper prefixes that are also suffixes. For the second character, <code>B</code>, again, there are no proper prefixes that are also suffixes, so the value is zero. For the third character, <code>A</code>, the longest proper prefix and suffix is <code>A</code>, which has a length of one. Continuing this pattern, the array should look like <code>[0, 0, 1, 2, 0, 1, 2]</code>.</p> <p>Once our prefix table is made, we can start iterating through the text. At any point, if a mismatch occurs, we can shift the pattern efficiently using the prefix table. We shift the pattern to the right based on the value of the prefix table prior to the current mismatched character of the pattern.</p>","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/#approach","title":"Approach","text":"<p>Assign two pointers, <code>i</code> and <code>j</code>, to represent the indices of the haystack and needle, respectively.</p> <p>Next, we compute the prefix table. Create an array with the size of the needle and initialize all values to zero. Set an integer to represent the length of the longest prefix and suffix to zero and an index to one.</p> <p>Until the index reaches the end of the needle size, we will repeat our algorithm: if the current index (a new index <code>i</code>) and the index at <code>len</code> have the same character, set the prefix table at <code>i</code> to <code>len + 1</code> and increment both <code>len</code> and <code>i</code>. Otherwise, if <code>len</code> is not zero, set the value to the previous value in the prefix table, but do not increment either variable. Finally, assign the value zero and increment <code>i</code>. Return the table.</p> <p>Until we cannot keep searching for a match, we will repeat our main algorithm. If the haystack and needle characters are equal, increment both pointers. If the needle has been exhausted, return the starting index.</p> <p>If there is a mismatch and the needle is not at the beginning, set the needle to the value of the prefix table at <code>j - 1</code>. Otherwise, increment <code>i</code>.</p> <p>If no match is found, return <code>-1</code>.</p>","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/#complexity","title":"Complexity","text":"","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n + m)\\) where \\(n\\) and \\(m\\) are the lengths of the needle and haystack, respectively. This is because we must iterate through the entire haystack and the needle.</p>","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(n)\\) where \\(n\\) is the length of the needle. We need this additional space to store our prefix table.</p>","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/28-find-the-index-of-the-first-occurrence-in-a-string/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int strStr(std::string haystack, std::string needle) {\n    unsigned short i = 0, j = 0;\n    std::vector&lt;unsigned short&gt; lps = computeLPS(needle);\n    while ((haystack.size() - i) &gt;= (needle.size() - j)) {\n      if (needle.at(j) == haystack.at(i)) {\n        i++;\n        j++;\n      }\n      if (j == needle.size()) return (i - j);\n      else if (i &lt; haystack.size() &amp;&amp; needle.at(j) != haystack.at(i)) {\n        if (j != 0) j = lps[j - 1];\n        else i++;\n      }\n    }\n    return -1;\n  }\n\nprivate:\n  std::vector&lt;unsigned short&gt; computeLPS(std::string needle) {\n    std::vector&lt;unsigned short&gt; lps(needle.size(), 0);\n    unsigned short len = 0, i = 1;\n    while (i &lt; needle.size()) {\n      if (needle.at(i) == needle.at(len)) lps[i++] = ++len;\n      else {\n        if (len != 0) len = lps[len - 1];\n        else lps[i++] = 0;\n      }\n    }\n    return lps;\n  }\n};\n</code></pre>","tags":["Easy","String","String Matching","Two Pointers"]},{"location":"solutions/29-divide-two-integers/","title":"Divide Two Integers","text":"","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/29-divide-two-integers/#intuition","title":"Intuition","text":"<p>We can divide two integers following the specified rules using repeated subtraction. If we repeatedly subtract our divisor from our dividend until our dividend is no longer greater in magnitude, we can get our quotient by counting the iterations.</p> <p>The problem with this approach is that it will take many iterations to complete for a very large dividend and a very small divisor. We can speed this up by doubling the divisor every time after we complete an iteration of subtraction. We will also need to increment our quotient accordingly.</p> <p>To solve for integer overflow, we can use an unsigned 32-bit integer and complete the algorithm using absolute values, adding in the sign and checking for overflow at the end.</p>","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/29-divide-two-integers/#approach","title":"Approach","text":"<p>Save the dividend and divisors as absolute values. Loop until the dividend is less than the divisor. Set a counter to zero, an extra variable to our absolute divisor, and a temporary quotient to one.</p> <p>We must first check if the dividend is equal to the divisor. If so, increment the quotient and exit the loop.</p> <p>Otherwise, we can add a second loop that works until our shifted divisor becomes zero (shift it past the integer limit) or our divisor is greater than our dividend. During each iteration, we can bit-shift our divisor once, increment our counter, and bit-shift our temporary quotient.</p> <p>After we exit the loop, subtract the dividend by the divisor shifted <code>i - 1</code> times, where <code>i</code> is our counter. Increment our quotient by the temporary quotient shifted to the left (the iterations will shift our quotient one too many times).</p> <p>Finally, we can check the sign and overflow, and return the quotient.</p>","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/29-divide-two-integers/#complexity","title":"Complexity","text":"","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/29-divide-two-integers/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(\\log(n^2))\\) based on the number of iterations we must complete.</p>","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/29-divide-two-integers/#space-complexity","title":"Space Complexity","text":"<p>We are not using additional space to solve this problem.</p>","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/29-divide-two-integers/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int divide(int dividend, int divisor) {\n    unsigned int quotient = 0, absDividend = std::abs(dividend), absDivisor = std::abs(divisor);\n    while (absDividend &gt;= absDivisor) {\n      unsigned int i = 0, shifted = absDivisor, tempQuotient = 1;\n      if (absDividend == absDivisor) {\n        quotient++;\n        break;\n      }\n      else {\n        while (shifted &amp;&amp; absDividend &gt; shifted) {\n          shifted &lt;&lt;= 1;\n          i++;\n          tempQuotient &lt;&lt;= 1;\n        }\n        absDividend -= (absDivisor &lt;&lt; (i - 1));\n        quotient += tempQuotient &gt;&gt; 1;\n      }\n    }\n    bool neg = (dividend &lt; 0 &amp;&amp; divisor &gt; 0) || (dividend &gt; 0 &amp;&amp; divisor &lt; 0);\n    if (quotient &gt; 2147483647 &amp;&amp; !neg) return 2147483647;\n    else if (quotient &gt; 2147483648 &amp;&amp; neg) return -2147483648;\n    return (neg ? (-1 * quotient) : quotient);\n  }\n};\n</code></pre>","tags":["Bit Manipulation","Math","Medium"]},{"location":"solutions/3-longest-substring-without-repeating-characters/","title":"Longest Substring Without Repeating Characters","text":"","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/3-longest-substring-without-repeating-characters/#intuition","title":"Intuition","text":"<p>The naive approach to solving this problem is to use a nested loop and calculate every possible substring in turn while keeping track of the longest substring without repeating characters. However, this has a time complexity of \\(O(n^2)\\). In order to solve this question in one pass, we need to use the sliding window approach.</p> <p>The sliding window will keep track of the current substring we are considering. Whenever we find a repeated character, we can shorten the window so that it moves forward and excludes the last location of the repeated character. We can continue until the window reaches the end of the string.</p>","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/3-longest-substring-without-repeating-characters/#approach","title":"Approach","text":"<p>Initialize two pointers, <code>left</code> and <code>right</code> to keep track of the start and end of the window. We also need a hash table to provideconstant-time lookup for the location of last characters found. For every iteration, first check if the current character (note that the current character is indexed using the <code>right</code> pointer) has already been found. If not, add the character and the current index to the map. Otherwise, check if the previous location of the current character is inside of our window. If not, we can just continue our loop. However, if the previous location is inside our current window, we need to increment the start of the window to be just after that previous location. At the end of each iteration, calculate the maximum value of the susbtring using the current window and the current maximum.</p>","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/3-longest-substring-without-repeating-characters/#complexity","title":"Complexity","text":"","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/3-longest-substring-without-repeating-characters/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) where \\(n\\) is the length of the input string <code>s</code>. This is because we are looping through the entire string once and each iteration is constant-time.</p>","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/3-longest-substring-without-repeating-characters/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(n)\\) where \\(n\\) is the length of the input string <code>s</code>. This is because we need space for \\(n\\) key-value pairs (at most).</p>","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/3-longest-substring-without-repeating-characters/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if (s.size() == 0) return 0;\n        unsigned short left = 0, right = 0, longestSubstr = 0;\n        std::unordered_map&lt;char, int&gt; lastCharLocation;\n        while (right &lt; s.size()) {\n            auto it = lastCharLocation.find(s[right]);\n            if (it != lastCharLocation.end() &amp;&amp; left &lt;= it -&gt; second) {\n                left = it -&gt; second + 1;\n            }\n            lastCharLocation.insert_or_assign(s[right], right);\n            longestSubstr = std::max&lt;unsigned short&gt;(longestSubstr, right++ - left + 1);\n        }\n        return longestSubstr;\n    }\n}\n</code></pre>","tags":["Hash Table","Medium","Sliding Window","String"]},{"location":"solutions/4-median-of-two-sorted-arrays/","title":"Median of Two Sorted Arrays","text":"","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/4-median-of-two-sorted-arrays/#intuition","title":"Intuition","text":"<p>At first glance, the naive solution comes to mind. Very simply, we can merge the two arrays, resort them, and return the median value. However, this requires \\(O(n + m)\\) memory and \\(O((n + m)\\log(n + m))\\) time. Is there any way we can use the fact that the arrays are already sorted to solve this problem?</p> <p>To best think about it, consider a different question. I will assume that the total number of elements is odd, however it is easy to consider the even case. Suppose the question is to find a partition of both arrays (i.e., two collections of elements, each possibly containing values from both arrays) such that all elements in the left collection are less than (or equal to) all elements in the right collection. This, by definition, is our median, because now we can look at the overlapping value (there must be one overlapped value, the median, since the total number of elements is odd).</p> <p>The reason this perspective makes the algorithm simpler is because we only need to keep track of a single value. In fact, we only need to consider a single array. Let us consider the shorter of the two arrays. We will loop until we find a solution. During each loop, we will pick a value to be the endpoint of the left partition in the shorter array (i.e., highest value in the left partition that belongs to our array). At this point, we have enough information to calculate the values for the highest left element for both arrays and the smallest right element for both arrays. We can use this to check for our success condition.</p> <p>The partitions can be rephrased simply into, \"How many elements of the shorter array will belong to the left partition?\". This is the same as searching for the highest in the left partition belonging to our array.</p>","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/4-median-of-two-sorted-arrays/#approach","title":"Approach","text":"<p>Consider the shorter array. Let us first guess that there will be \\(\\frac{n}{2}\\) elements from our array in the left collection. We can find the index of the left collection for the second array. We must take the total size of the left partition (\\((n + m)\\) / 2) and subtract the amount of elements already chosen (remember to account for zero-based indexing). We can now use these indices to get the element values for the lowest and highest partition values in both arrays. Once doing so, we know we have the median if the highest left from the first array is less than the lowest right from the second array, and vice versa. Otherwise, we adjust our initial guess, either subtracting one if our array has too many elements in the left partition, or adding one for the opposite case.</p>","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/4-median-of-two-sorted-arrays/#complexity","title":"Complexity","text":"","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/4-median-of-two-sorted-arrays/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(\\min\\{n, m\\})\\) because we are traversing the shorter array. Since we can only add or subtract one from our initial guess, we cannot achieve logarithmic time complexity.</p>","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/4-median-of-two-sorted-arrays/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are only allocating a handful of variables to simplify our code.</p>","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/4-median-of-two-sorted-arrays/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        const unsigned short n = nums1.size(), m = nums2.size();\n        if (m &lt; n) return findMedianSortedArrays(nums2, nums1);\n        if (n == 0) {\n            if (m % 2) return nums2[m / 2];\n            return (nums2[m / 2] + nums2[m / 2 - 1]) / 2.0;\n        }\n        const unsigned short total = n + m;\n        short mid1 = n / 2;\n        while (true) {\n            const short mid2 = total / 2 - (mid1 + 1) - 1;\n            const int l1 = (mid1 &gt;= 0) ? nums1.at(mid1) : std::numeric_limits&lt;int&gt;::min();\n            const int r1 = ((mid1 + 1) &lt; n) ? nums1.at(mid1 + 1) : std::numeric_limits&lt;int&gt;::max();\n            const int l2 = (mid2 &gt;= 0) ? nums2.at(mid2) : std::numeric_limits&lt;int&gt;::min();\n            const int r2 = ((mid2 + 1) &lt; m) ? nums2.at(mid2 + 1) : std::numeric_limits&lt;int&gt;::max();\n            if ((l1 &lt;= r2) &amp;&amp; (l2 &lt;= r1)) {\n                if (total % 2) return std::min(r1, r2);\n                return (std::max(l1, l2) + std::min(r1, r2)) / 2.0;\n            } else if (l1 &gt; r2) mid1--;\n            else mid1++;\n        }\n        throw;\n    }\n};\n</code></pre>","tags":["Array","Binary Search","Divide and Conquer","Hard"]},{"location":"solutions/5-longest-palindromic-substring/","title":"Longest Palindromic Substring","text":"","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/5-longest-palindromic-substring/#intuition","title":"Intuition","text":"<p>Without loss of generality, we can assume the longest palindrome is odd. The naive approach to solving this algorithm uses an \\(O(n^3)\\) approach to check all possible substrings.</p> <p>We can solve this problem more efficiently by considering a single loop of the input string. For each character, assume it is a center of a palindrome and expand outwards. Doing this for all characters will give us the longest palindromic substring for the input array. This approach is \\(O(n^2)\\).</p> <p>We can also solve this problem in linear time by using Manacher's Algorithm. The idea behind this algorithm follows from the previous approach. However, by knowing the lengths of previously calculated palindromes, we can skip checking certain centers because we can mathematically prove that the palindrome surrounding that center is no better than our current longest palindrome. This is best illustrated with an example.</p> <p>Assume we have the string \"abaxabaxabb\". We will expand around the first character ('a') and see that the palindrome around that center is one. Next, we must expand around the first 'b'. The palindrome surrounding that center is three. Similarly, the 'x' is a palindrome of 7. Now, we can demonstrate Manacher's algorithm to choose the next center. If we look at the letters following 'x' that are contained within the palindrome surrounding 'x', we have an 'a', 'b', and 'a'. Without any calculations, we can conclude that the first 'a' must be a palindrome of one (it should mirror the 'a' before the 'x'). For the 'b' we can conclude that the palindrome must be three (it should mirror the other 'b'). Rather, it must be at least three because we do not know what lies beyond the 'a' following the 'b'. Thus, we can skip the first 'a' and instead expand around 'b'.</p> <p>Overall, we must consider four cases to choose the next center. The first case is that the palindrome is entirely contained within a larger palindrome. We can assign the palindrome at this center to the value belonging to its mirror and proceed with the next character. The second case is that we are at the end of the input string. The third case is that the mirror value extends beyond the containing palindrome. We can assign the palindrome around this center to be up until the end of the containing palindrome (you can check yourself that if this was not true, namely, that the palindrome could extend beyond the containing palindrome, then the containing palindrome was calculated incorrectly). The only case where we choose a center is when the mirror value does not extend beyond the containing palindrome and applying it to our current center takes us to the edge of the containing palindrome.</p> <p>As for even-length palindromes, we can manipulate the input string by adding special characters (e.g., '#') between each letter to make the string odd-length. Now, even-length palindromes will in fact be odd-length palindromes about a special character.</p> <p>Note: I tried my best to explain the algorithm using words but I encourage you to watch the linked video and work through examples by hand before trying to code the algorithm if you are having trouble understanding.</p>","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/5-longest-palindromic-substring/#approach","title":"Approach","text":"<p>Add a special character '@' at the start (to avoid overflow) and after each character ('#').</p> <p>Next, loop through the modified input string, calculating the palindrome at each center. Expand outwards in both directions and keep track of the palindrome length in a corresponding array.</p> <p>If the palindrome is greater than one, use the cases to decide which center to pick next. By default, we pick the next character. For this specific design, overflow is automatically checked by the external loop so we can ignore it. If the proceeding character(s) have a palindrome entirely contained but not at the right edge, we can skip. If the corresponding mirror extends beyond the containing palindrome, we can assign the center the value such that it extends up to, but not past, the containing palindrome. Otherwise, the character is our next center.</p> <p>Return the substring using the maximum palindrome value. Remember to strip the special characters before returning the value.</p>","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/5-longest-palindromic-substring/#complexity","title":"Complexity","text":"","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/5-longest-palindromic-substring/#time-complexity","title":"Time Complexity","text":"<p>The time complexity of Manacher's Algorithm is \\(O(n)\\).</p>","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/5-longest-palindromic-substring/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(n)\\) because we need to keep track of an array with lengths of palindromes at each center.</p>","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/5-longest-palindromic-substring/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) {\n      std::string temp = \"@\";\n      for (int i = 0; i &lt; s.size(); i++) {\n        temp += s[i];\n        temp += '#';\n      }\n      s = temp;\n      const unsigned short n = s.size();\n      std::vector&lt;int&gt; p(n);\n      unsigned short i = 1, maxCenter = 0;\n      while (i &lt; n - 1) {\n        unsigned short expand = 1;\n        while (s[i - expand] == s[i + expand]) expand++;\n        p.at(i) = (expand - 1) * 2 + 1;\n        if (p.at(i) &gt; p.at(maxCenter)) maxCenter = i;\n        unsigned short mirror = expand - 1, nextCenter = i + 1;\n        for (int j = 1; j &lt;= mirror; j++) {\n          const unsigned short opposite = (p.at(i - j) - 1) / 2 + j;\n          if (opposite &lt; mirror) p.at(i + j) = p.at(i - j);\n          else if (opposite &gt; mirror) p.at(i + j) = (mirror - j) * 2 + 1;\n          else {\n            nextCenter = i + j;\n            break;\n          }\n        }\n        i = nextCenter;\n      }\n      s = s.substr(maxCenter - ((p.at(maxCenter) - 1) / 2), p.at(maxCenter));\n      std::erase(s, '#');\n      return s;\n    }\n};\n</code></pre>","tags":["Dynamic Programming","Medium","String"]},{"location":"solutions/6-zigzag-conversion/","title":"Zigzag Conversion","text":"","tags":["Medium","String"]},{"location":"solutions/6-zigzag-conversion/#intuition","title":"Intuition","text":"<p>The easiest approach to solve this problem is to consider each row as an array, traverse the string in such a way that we populate the arrays representing the rows to get the zigzag pattern, and finally read in the values from each row consecutively to get the final string. However, this costs \\(O(m)\\) memory, where \\(m\\) is the number of rows.</p> <p>This problem can be done with constant space complexity. Instead of using rows to store the data, we just need a formula to calculate the next index of the string to append to our return value. There are two cases here for calculating the increment value; the first and last row, and all of the middle rows.</p> <p>First, note that for any given row, the first character will be <code>s[i]</code> where <code>i</code> is the row we are iterating over. The first and last row for any given <code>numRows</code> value increments the index by <code>numRows * 2 - 2</code>. For the middle values, the pattern is more obscure. Consider the first example on the LeetCode website. The second row jumps by a constant value of two, two less than the jump for the first (and last) row which is four. But for the second example, the second row jumps by four, then two, then four again, etc. The third row jumps by two, then four, then two again. If you continue with examples of higher value of <code>numRows</code>, you will notice a pattern where each consecutive row starts by incrementing two less than the previous row, then immediately incrementing the difference between the initial jump (used for the first and last row) and the increment we just applied.</p> <p>If we can formulate this pattern, we can loop over the string and append each character until we are finished.</p>","tags":["Medium","String"]},{"location":"solutions/6-zigzag-conversion/#approach","title":"Approach","text":"<p>First, we can consider the trivial cases where <code>numRows</code> is one or <code>s.size() &lt;= numRows</code>. In either case we can immediately return <code>s</code>.</p> <p>We can initialize our increment value to be <code>numRows - 2 * 2</code> as we know we will need this for row one (and later for the last row). Iterate over the rows, appending the character corresponding to the current row number to our result.</p> <p>Now add another loop to collect all values for the current row. The only difficult part here is to formalize our pattern we described earlier. We can see that for the first row, we can just use our existing increment value. However for middle rows, we can use this existing value once before needing to calculate an intermediate jump. This intermediate jump is given by our initial increment (<code>numRows - 2 * 2</code>) minus the increment we just used. Remember to add out-of-bounds checks before appending characters here because we are incrementing manually (not through the for-loop).</p> <p>At the end of the row, we can decrease the increment value used by two. If the increment becomes zero, we are at the last row and can reset it to <code>numRows - 2 * 2</code>.</p>","tags":["Medium","String"]},{"location":"solutions/6-zigzag-conversion/#complexity","title":"Complexity","text":"","tags":["Medium","String"]},{"location":"solutions/6-zigzag-conversion/#time-complexity","title":"Time Complexity","text":"<p>Although we are using two for-loops, the time complexity is still \\(O(n)\\) (where \\(n\\) is the size of the string) because we are only reaching each character once.</p>","tags":["Medium","String"]},{"location":"solutions/6-zigzag-conversion/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Medium","String"]},{"location":"solutions/6-zigzag-conversion/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    std::string convert(std::string s, int numRows) {\n      if (numRows == 1 || s.size() &lt;= numRows) return s;\n      std::string zigzag = \"\";\n      unsigned short incr = numRows * 2 - 2;\n      for (int i = 0; i &lt; numRows; i++) {\n        zigzag += s[i];\n        for (int j = i; j &lt; s.size(); ) {\n          j += incr;\n          if (j &gt;= s.size()) break;\n          zigzag += s[j];\n          if (i != 0 &amp;&amp; i != numRows - 1) {\n            j += (numRows * 2 - 2) - incr;\n            if (j &gt;= s.size()) break;\n            zigzag += s[j];\n          }\n        }\n        incr -= 2;\n        if (incr == 0) incr = numRows * 2 - 2;\n      }\n      return zigzag;\n    }\n};\n</code></pre>","tags":["Medium","String"]},{"location":"solutions/7-reverse-integer/","title":"Reverse Integer","text":"","tags":["Math","Medium"]},{"location":"solutions/7-reverse-integer/#intuition","title":"Intuition","text":"<p>This problem is only made non-trivial by the variable-size constraint.</p> <p>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</p> <p>The problem this poses is that we need a way to check if the input will overflow before we try and reverse it. Of course, you could use a string to store the number and bypass the size requirements that way, but that still takes extra memory.</p> <p>Consider any given input. We know that the input is a valid, signed, 32-bit integer. It follows that we can reverse every digit except the last without causing overflow. Therefore, we just need to check the last digit prior to reversing it to avoid overflow.</p>","tags":["Math","Medium"]},{"location":"solutions/7-reverse-integer/#approach","title":"Approach","text":"<p>Loop until the input number is zero. At the start of the iteration, extract the last digit. Next, remove the last digit from the input. We can check if our reversed number (so-far) has overflowed. If not, add the new digit to the reversed number. If we are at the last digit, we can check if the reversed value is the same as the minimum and maximum integer values. If so, we can check if the final digit causes overflow.</p>","tags":["Math","Medium"]},{"location":"solutions/7-reverse-integer/#complexity","title":"Complexity","text":"","tags":["Math","Medium"]},{"location":"solutions/7-reverse-integer/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) because we are looping for each number present in the input.</p>","tags":["Math","Medium"]},{"location":"solutions/7-reverse-integer/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\) because we are not using extra space outside of the return variable.</p>","tags":["Math","Medium"]},{"location":"solutions/7-reverse-integer/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n    int reverse(int x) {\n      const int minInt = std::numeric_limits&lt;int&gt;::min(), maxInt = std::numeric_limits&lt;int&gt;::max();\n      int reverse = 0;\n      while (x) {\n        const short digit = x % 10;\n        x /= 10;\n        if ((reverse &gt; maxInt / 10) || ((reverse == maxInt / 10) &amp;&amp; (digit &gt;= maxInt % 10))) return 0;\n        if ((reverse &lt; minInt / 10) || ((reverse == minInt / 10) &amp;&amp; (digit &lt;= minInt % 10))) return 0;\n        reverse = (reverse * 10) + digit;\n      }\n      return reverse;\n    }\n};\n</code></pre>","tags":["Math","Medium"]},{"location":"solutions/8-string-to-integer/","title":"String to Integer","text":"","tags":["Medium","String"]},{"location":"solutions/8-string-to-integer/#intuition","title":"Intuition","text":"<p>For this problem, we will just be implementing the algorithm provided in the description.</p>","tags":["Medium","String"]},{"location":"solutions/8-string-to-integer/#approach","title":"Approach","text":"<p>I recommend splitting up the overall algorithm into multiple parts. This makes the code easier to read and debug.</p> <p>First, we need to check that an empty string is not provided. Next, we can remove leading whitespace. If removing leading whitespace leaves an empty string, we can return zero. At this point, I decided to keep track of the negative and insert it later on. Then, we must format the string into a number that is ready for conversion. Disregard the string from the first non-digit to the end. Remove leading zeroes. Make sure to include checks for where the string may become empty. To convert the string, simply read in characters one by one, checking for overflow at each iteration. Luckily, we can use 64-bit integers so we don't need to work around for overflow.</p>","tags":["Medium","String"]},{"location":"solutions/8-string-to-integer/#complexity","title":"Complexity","text":"","tags":["Medium","String"]},{"location":"solutions/8-string-to-integer/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\). We are using methods and a loop which are up to \\(O(n)\\) time.</p>","tags":["Medium","String"]},{"location":"solutions/8-string-to-integer/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Medium","String"]},{"location":"solutions/8-string-to-integer/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  int myAtoi(std::string s) {\n    if (s.empty()) return 0;\n    s = removeLeadingWhitespace(s);\n    const bool neg = (s[0] == '-');\n    s = formatStr(s);\n    if (s.size() == 0) return 0;\n    return convert(s, neg);\n  }\n\nprivate:\n  std::string removeLeadingWhitespace(std::string s) {\n    s.erase(s.begin(), s.begin() + ((s.find_first_not_of(' ') != -1) ? s.find_first_not_of(' ') : s.size()));\n    return s;\n  }\n\n  int convert(std::string s, bool neg) {\n    long converted = 0;\n    for (auto ch : s) {\n      converted = ((converted * 10) + ((ch - '0') * (neg ? -1 : 1)));\n      if (converted &gt; std::numeric_limits&lt;int&gt;::max()) return std::numeric_limits&lt;int&gt;::max();\n      if (converted &lt; std::numeric_limits&lt;int&gt;::min()) return std::numeric_limits&lt;int&gt;::min();\n    }\n    return converted;\n  }\n\n  std::string formatStr(std::string s) {\n    if ((s[0] == '-') || (s[0] == '+')) s.erase(s.begin(), s.begin() + 1);\n    if (s.find_first_not_of(\"0123456789\") != -1) s.erase(s.begin() + s.find_first_not_of(\"0123456789\"), s.end());\n    if (s.empty()) return s;\n    s.erase(s.begin(), s.begin() + ((s.find_first_not_of('0') != -1) ? s.find_first_not_of('0') : s.size()));\n    return s;\n  }\n};\n</code></pre>","tags":["Medium","String"]},{"location":"solutions/9-palindrome-number/","title":"Palindrome Number","text":"","tags":["Easy","Math"]},{"location":"solutions/9-palindrome-number/#intuition","title":"Intuition","text":"<p>To check if a number is a palindrome, we simply need to reverse the number and check if it is equal to the input value.</p>","tags":["Easy","Math"]},{"location":"solutions/9-palindrome-number/#approach","title":"Approach","text":"<p>Copy the input value into another variable we can manipulate. We need to keep the input value untouched to check it later on. Next, we can reverse the number. At each iteration, take the last digit of the copied input and place it onto the end of the reversed digit.</p>","tags":["Easy","Math"]},{"location":"solutions/9-palindrome-number/#complexity","title":"Complexity","text":"","tags":["Easy","Math"]},{"location":"solutions/9-palindrome-number/#time-complexity","title":"Time Complexity","text":"<p>The time complexity is \\(O(n)\\) because we are doing \\(n\\) iterations to reverse the number.</p>","tags":["Easy","Math"]},{"location":"solutions/9-palindrome-number/#space-complexity","title":"Space Complexity","text":"<p>The space complexity is \\(O(1)\\).</p>","tags":["Easy","Math"]},{"location":"solutions/9-palindrome-number/#code","title":"Code","text":"<pre><code>class Solution {\npublic:\n  bool isPalindrome(int x) {\n    if (x &lt; 0) return false;\n    int xCopy = x;\n    long reversed = 0;\n    while (xCopy) {\n      reversed = (reversed * 10) + (xCopy % 10);\n      xCopy /= 10;\n    }\n    return (x == reversed);\n  }\n};\n</code></pre>","tags":["Easy","Math"]},{"location":"tags/","title":"Tags","text":"<p>The following is a list of relevant tags:</p>"},{"location":"tags/#array","title":"Array","text":"<ul> <li>1 - Two Sum</li> <li>Container With Most Water</li> <li>Three Sum</li> <li>Three Sum Closest</li> <li>Four Sum</li> <li>Remove Duplicates From Sorted Array</li> <li>Remove Element</li> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#backtracking","title":"Backtracking","text":"<ul> <li>Letter Combinations of a Phone Number</li> <li>Generate Parentheses</li> </ul>"},{"location":"tags/#binary-search","title":"Binary Search","text":"<ul> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#bit-manipulation","title":"Bit Manipulation","text":"<ul> <li>Divide Two Integers</li> </ul>"},{"location":"tags/#divide-and-conquer","title":"Divide and Conquer","text":"<ul> <li>Merge K Sorted Lists</li> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#dynamic-programming","title":"Dynamic Programming","text":"<ul> <li>Regular Expression Matching</li> <li>Generate Parentheses</li> <li>Longest Palindromic Substring</li> </ul>"},{"location":"tags/#easy","title":"Easy","text":"<ul> <li>1 - Two Sum</li> <li>Roman to Integer</li> <li>Longest Common Prefix</li> <li>Valid Parentheses</li> <li>Merge Two Sorted Lists</li> <li>Remove Duplicates From Sorted Array</li> <li>Remove Element</li> <li>Find the Index of the First Occurrence in a String</li> <li>Palindrome Number</li> </ul>"},{"location":"tags/#greedy","title":"Greedy","text":"<ul> <li>Container With Most Water</li> </ul>"},{"location":"tags/#hard","title":"Hard","text":"<ul> <li>Regular Expression Matching</li> <li>Merge K Sorted Lists</li> <li>Reverse Nodes in K-Group</li> <li>Median of Two Sorted Arrays</li> </ul>"},{"location":"tags/#hash-table","title":"Hash Table","text":"<ul> <li>1 - Two Sum</li> <li>Integer to Roman</li> <li>Roman to Integer</li> <li>Letter Combinations of a Phone Number</li> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#heap","title":"Heap","text":"<ul> <li>Merge K Sorted Lists</li> </ul>"},{"location":"tags/#linked-list","title":"Linked List","text":"<ul> <li>Remove Nth Node From End of List</li> <li>Add Two Numbers</li> <li>Merge Two Sorted Lists</li> <li>Merge K Sorted Lists</li> <li>Swap Nodes in Pairs</li> <li>Reverse Nodes in K-Group</li> </ul>"},{"location":"tags/#math","title":"Math","text":"<ul> <li>Integer to Roman</li> <li>Roman to Integer</li> <li>Add Two Numbers</li> <li>Divide Two Integers</li> <li>Reverse Integer</li> <li>Palindrome Number</li> </ul>"},{"location":"tags/#medium","title":"Medium","text":"<ul> <li>Container With Most Water</li> <li>Integer to Roman</li> <li>Four Sum</li> <li>Add Two Numbers</li> <li>Generate Parentheses</li> <li>Swap Nodes in Pairs</li> <li>Divide Two Integers</li> <li>Longest Substring Without Repeating Characters</li> <li>Longest Palindromic Substring</li> <li>Zigzag Conversion</li> <li>Reverse Integer</li> <li>String to Integer</li> </ul>"},{"location":"tags/#merge-sort","title":"Merge Sort","text":"<ul> <li>Merge K Sorted Lists</li> </ul>"},{"location":"tags/#recursion","title":"Recursion","text":"<ul> <li>Regular Expression Matching</li> <li>Merge Two Sorted Lists</li> <li>Swap Nodes in Pairs</li> <li>Reverse Nodes in K-Group</li> </ul>"},{"location":"tags/#sliding-window","title":"Sliding Window","text":"<ul> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"tags/#sorting","title":"Sorting","text":"<ul> <li>Three Sum</li> <li>Three Sum Closest</li> <li>Four Sum</li> </ul>"},{"location":"tags/#stack","title":"Stack","text":"<ul> <li>Valid Parentheses</li> </ul>"},{"location":"tags/#string","title":"String","text":"<ul> <li>Regular Expression Matching</li> <li>Integer to Roman</li> <li>Roman to Integer</li> <li>Longest Common Prefix</li> <li>Letter Combinations of a Phone Number</li> <li>Valid Parentheses</li> <li>Generate Parentheses</li> <li>Find the Index of the First Occurrence in a String</li> <li>Longest Substring Without Repeating Characters</li> <li>Longest Palindromic Substring</li> <li>Zigzag Conversion</li> <li>String to Integer</li> </ul>"},{"location":"tags/#string-matching","title":"String Matching","text":"<ul> <li>Find the Index of the First Occurrence in a String</li> </ul>"},{"location":"tags/#trie","title":"Trie","text":"<ul> <li>Longest Common Prefix</li> </ul>"},{"location":"tags/#two-pointers","title":"Two Pointers","text":"<ul> <li>Container With Most Water</li> <li>Three Sum</li> <li>Three Sum Closest</li> <li>Four Sum</li> <li>Remove Nth Node From End of List</li> <li>Remove Duplicates From Sorted Array</li> <li>Remove Element</li> <li>Find the Index of the First Occurrence in a String</li> </ul>"}]}